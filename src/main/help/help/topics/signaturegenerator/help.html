<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <META name="generator" content=
    "HTML Tidy for Java (vers. 2009-12-01), see jtidy.sourceforge.net">
    <META http-equiv="Content-Language" content="en-us">
    <META http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <META name="GENERATOR" content="Microsoft FrontPage 4.0">
    <META name="ProgId" content="FrontPage.Editor.Document">

    <TITLE>Help file for GARBS</TITLE>
    <LINK rel="stylesheet" type="text/css" href="../../shared/Frontpage.css">
  </HEAD>

  <BODY>
    <H1><a name="Signature_Generator"></a>Help for Ghidra Artificer of Runtime Binary Signatures</H1>

    <P>Simply select the instructions in the disassembly view that you wish to scan for and press the <img src="../../shared/signature.png"></img> button.
    A window will open and the plugin will begin generating and validating signatures until it finds an optimial match. The signature formats generated by the plugin are NSig fnv1a (64bit), NSig CRC (64bit) (A.K.A. WavSig 64bit), and traditional signatures.
    </P>
    <BR/>
    <H2>Documentation for NSig Signature formats:</H2>
    <BR/>
    <H3>NSig fnv1a (64bit)</H3>
    <P>
    This format uses a 64bit bitfield as the mask, each bit corresponds to one byte, first a copy buffer that is 64 bytes long is made from memory, if the bit is a one that byte will be left as is when hashing the copy buffer you are testing; if it is zero, the copy buffer will have that byte zeroed out before hashing.
    A 64bit fnv1a hash is calculated from the copy buffer and compared with the signature provided by this plugin, if they match you've found your code.
    </P>
    <BR>
    <P>
    The FNV1A offset basis used is: 0xCBF29CE484222325.
    </P>
    <P>
    The FNV1A prime used is: 0x100000001B3.
    </P>
    <BR/>
    <H3>NSig CRC (64bit) (A.K.A. WavSig 64bit)</H3>
    <P>
    This format uses a 64bit bitfield as the mask, each bit corresponds to one byte, first a copy buffer that is 64 bytes long is made from memory, if the bit is a one that byte will be left as is when calculating the checksum of the copy buffer you are testing; if it is zero, the copy buffer will have that byte zeroed out before calculating the checksum.
    A 64bit CRC checksum is calculated from the copy buffer and compared with the signature provided by this plugin, if they match you've found your code.
    </P>
    <BR>
    <P>
    The CRC Polynomial used is: 0xC96C5795D7870F42.
    </P>
  </BODY>
</HTML>
